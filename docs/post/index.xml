<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Antranig Basman</title>
    <link>https://ponder.org.uk/post/</link>
    <description>Recent content in Posts on Antranig Basman</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>amb26web@ponder.org.uk (Antranig Basman)</managingEditor>
    <webMaster>amb26web@ponder.org.uk (Antranig Basman)</webMaster>
    <lastBuildDate>Tue, 01 Jul 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ponder.org.uk/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Archaeology of Glitches</title>
      <link>https://ponder.org.uk/post/2025-07-01-archaeology-of-glitches/</link>
      <pubDate>Tue, 01 Jul 2025 00:00:00 +0000</pubDate><author>amb26web@ponder.org.uk (Antranig Basman)</author>
      <guid>https://ponder.org.uk/post/2025-07-01-archaeology-of-glitches/</guid>
      <description>In 2024 I was working on a small project that I wanted to be able to be handed over, and wondered what was the most congenial way out there of rendering apps that wouldn&amp;rsquo;t bring in too heavy a dependency. My eye was caught by the following passage in preact-signals&amp;rsquo; test cases:&#xA;it(&amp;#34;should drop A-&amp;gt;B-&amp;gt;A updates&amp;#34;, async () =&amp;gt; { // A // / | // B | &amp;lt;- Looks like a flag doesn&amp;#39;t it?</description>
    </item>
    <item>
      <title>Substrates Vision Statement</title>
      <link>https://ponder.org.uk/post/2025-06-03-substrates-vision/</link>
      <pubDate>Tue, 03 Jun 2025 00:00:00 +0000</pubDate><author>amb26web@ponder.org.uk (Antranig Basman)</author>
      <guid>https://ponder.org.uk/post/2025-06-03-substrates-vision/</guid>
      <description>This is my vision statement submitted to the Substrates-25 workshop held in Prague in June 2025, co-located with &amp;lt;Programming 2025&amp;gt;.&#xA;To disclosable computing through concrete abstractions What is a substrate? Jonathan Edwards defines a substrate as embodying the following properties:&#xA;A complete and self-sufficient programming system, with a persistent code &amp;amp; data store, providing a direct-manipulation UI on that state. Supports live programming. Programming &amp;amp; using are on a spectrum, not distinct.</description>
    </item>
    <item>
      <title>An era for new notations</title>
      <link>https://ponder.org.uk/post/2025-04-19-new-notation-era/</link>
      <pubDate>Sat, 19 Apr 2025 00:00:00 +0000</pubDate><author>amb26web@ponder.org.uk (Antranig Basman)</author>
      <guid>https://ponder.org.uk/post/2025-04-19-new-notation-era/</guid>
      <description>I argue that there has never been a more promising time for developing fruitful new notations.&#xA;Some, considering the enormous success of modern LLMs in solving increasingly complex &amp;ldquo;problems&amp;rdquo; – in terms of translating a verbal or pictorial design specification into code – means programming is now a &amp;ldquo;solved&amp;rdquo; problem. They imagine a future where humans no longer need to understand or write code.&#xA;I believe this is wrong on several accounts.</description>
    </item>
    <item>
      <title>Coming Out of the Shadows</title>
      <link>https://ponder.org.uk/post/2025-04-13-coming-out-of-the-shadows/</link>
      <pubDate>Sun, 13 Apr 2025 00:00:00 +0000</pubDate><author>amb26web@ponder.org.uk (Antranig Basman)</author>
      <guid>https://ponder.org.uk/post/2025-04-13-coming-out-of-the-shadows/</guid>
      <description>Or – &amp;ldquo;Evading Gilad&amp;rsquo;s Comparison&amp;rdquo;.&#xA;A 2014 posting of Gilad Bracha&amp;rsquo;s, A DOMain of shadows, has prompted a lot of thought over the years. I refer to it in passing in last month&amp;rsquo;s On UI as Code but this week a line of argument became a bit clearer on how the comparison in the posting might be dodged.&#xA;Gilad&amp;rsquo;s note is about the design tension constantly pushing complexity into any purportedly &amp;ldquo;simple&amp;rdquo; user-facing language, that we might call a DSL.</description>
    </item>
    <item>
      <title>On UI as code</title>
      <link>https://ponder.org.uk/post/2025-03-20-ui-as-code/</link>
      <pubDate>Thu, 20 Mar 2025 00:00:00 +0000</pubDate><author>amb26web@ponder.org.uk (Antranig Basman)</author>
      <guid>https://ponder.org.uk/post/2025-03-20-ui-as-code/</guid>
      <description>UI as Code as a named slogan originated in the context of Dart&amp;rsquo;s Flutter UI toolkit created by Google. It is centrally described by Bob Nystrom in this thoughtful posting Marking Dart a Better Language for UI. I see it as part of a wider trend in many environments to express designs in general-purpose programming language code rather than configuration languages with less expressive power. For example, ESLint&amp;rsquo;s flat config system introduced in 2022 moves its previous JSON-based linting configuration into JavaScript code.</description>
    </item>
    <item>
      <title>On Development Speed</title>
      <link>https://ponder.org.uk/post/2025-03-14-development-speed/</link>
      <pubDate>Fri, 14 Mar 2025 00:00:00 +0000</pubDate><author>amb26web@ponder.org.uk (Antranig Basman)</author>
      <guid>https://ponder.org.uk/post/2025-03-14-development-speed/</guid>
      <description>A recent posting Why the Latest JavaScript Frameworks Are a Waste of Time sparks a short train of thought. As well as the characteristically disrespectful tone of discussion that technical people often adopt, and the suggestion, contrary to my speculations looking at DOM reconciliation, that people really do use low-level benchmarks when choosing frameworks, is the notion of frameworks contributing to development speed. One commentor invites us to watch him against the clock to implement a front end in Svelte rather than React.</description>
    </item>
    <item>
      <title>Benchmarking DOM reconciliation algorithms</title>
      <link>https://ponder.org.uk/post/2025-02-07-benchmarking-dom-reconciliation/</link>
      <pubDate>Fri, 07 Feb 2025 00:00:00 +0000</pubDate><author>amb26web@ponder.org.uk (Antranig Basman)</author>
      <guid>https://ponder.org.uk/post/2025-02-07-benchmarking-dom-reconciliation/</guid>
      <description>Since the Infusion 6 renderer is close to being a reality, it is time to understand the characteristics of some of the various DOM reconciliation algorithms out there.&#xA;Could we do without a virtual DOM entirely? To start with is the question of whether we even really want one at all — the classic Svelte Virtual DOM is pure overhead post has been though its various hype cycles but 7 years later the majority of frameworks out there still have one so the consequences are clearly not as clear-cut as the argument would have it.</description>
    </item>
  </channel>
</rss>
